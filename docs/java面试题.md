# java面试题

# equals和==区别

==：如果比较的是基本数据类型，那么比较的是变量值

如果比较的是引用数据类型，那么比较的是地址值（两个对象是否指向同一块内存）

equals默认就是使用==方法

重写一般就是比较属性值



# hashmap

```java
HashMap<String,String> map = new HashMap<String,String>();
map.put("刘德华","张惠妹");
map.put("张学友","大S");
```

过程：

- 计算刘德华的hashcode值
- 刘德华的hashcode为20977295 数组长度为 16则要存储在数组索引为 20977295%16=1的地方
  - 计算出hashcode值进行取余
- 数组索引为1的地方是空的，这种情况很简单，直接将元素放进去就好了
- 已经有元素占据了索引为1的位置，这种情况下我们需要判断一下该位置的元素和当前元素是否相等
- 如果两者相等则直接覆盖，如果不等则在原元素下面使用链表的结构存储该元素
- 每个元素节点都有一个next属性指向下一个节点，这里由数组结构变成了数组+链表结构
- 因为链表中元素太多的时候会影响查找效率，所以当链表的元素个数达到8的时候使用链表存储就转变成了使用红黑树存储，原因就是红黑树是平衡二叉树，在查找性能方面比链表要高



HashMap中有两个重要的参数：初始容量大小和加载因子，初始容量大小是创建时给数组分配的容量大小，默认值为16，加载因子默认0.75f，用数组容量大小乘以加载因子得到一个值，一旦数组中存储的元素个数超过该值就会调用rehash方法将数组容量增加到原来的两倍，专业术语叫做扩容



# 多线程

ThreadPoolExecutor



# Sring buffer和String Builder区别

- StringBuffer和StringBuilder的方法和功能是完全等阶的
- StringBuffer中的方法大都采用了synchronized关键字进行修饰,因此是线程安全的
- 在单线程程序下，StringBuilder效率更快，因为它不需要加锁，不具备多线程安全，而StringBuffer每次都需要判断锁，效率相对更低



# redis

**哨兵模式**：如果主机宕掉，哨兵会从从机中选择一台作为主机

并加她设置为其他从机的主机，原来主机再次启动也会成为从机



数据类型

|  类型  |           含义           |
| :----: | :----------------------: |
| string |          字符串          |
|  list  |       可重复的集合       |
|  set   |      不可重复的集合      |
|  hash  | 类似于Map<String,String> |
|  zset  |       带分数的set        |



RDB持久化

RDB：在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里

RDB是默认开启的

RDB的缺点是最后一次持久化后的数据可能丢失

RDB触发

​	①基于自动保存的策略

​	②执行save，或者bgsave命令！执行时，是阻塞状态。

​	③执行flushall命令，也会产生dump.rdb，但里面是空的，没有意义。

​	④当执行shutdown命令时，也会主动地备份数据



- AOF是以日志的形式来记录每个写操作，将每一次对数据进行修改，都把新建、修改数据的命令保存到指定文件中。Redis重新启动时读取这个文件，重新执行新建、修改数据的命令恢复数据。
- 默认不开启，需要手动开启
-  AOF文件的保存路径，同RDB的路径一致。
- AOF在保存命令的时候，只会保存对数据有修改的命令，也就是写操作！



当RDB和AOF存的不一致的情况下，按照AOF来恢复。因为AOF是对RDB的补充。备份周期更短，也就更可靠



优点：

- 备份机制更稳健，丢失数据概率更低
- 可读的日志文本，通过操作AOF稳健，可以处理误操作



- 比起RDB占用更多的磁盘空间
- 恢复备份速度要慢